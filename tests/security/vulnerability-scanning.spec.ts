import { test, expect, type Page } from '@playwright/test'

// Security testing configuration
const SECURITY_CONFIG = {
  // Common injection payloads for testing
  injectionPayloads: {
    xss: [
      '<script>alert("xss")</script>',
      '"><script>alert("xss")</script>',
      'javascript:alert("xss")',
      '<img src=x onerror=alert("xss")>',
      '${alert("xss")}',
      '{{constructor.constructor("alert(\\"xss\\")")()}}',
    ],
    sqlInjection: [
      "'; DROP TABLE users; --",
      '" OR "1"="1',
      "' UNION SELECT * FROM users --",
      "1' OR 1=1#",
    ],
    commandInjection: [
      '; cat /etc/passwd',
      '| whoami',
      '`whoami`',
      '$(whoami)',
      '; ls -la',
      '& net user',
    ],
    pathTraversal: [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
      '....//....//....//etc/passwd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
    ],
    yamlBombs: [
      // YAML bomb patterns that could cause DoS
      'a: &anchor ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]\nb: &anchor2 [*anchor,*anchor,*anchor,*anchor,*anchor,*anchor,*anchor,*anchor,*anchor]\nc: &anchor3 [*anchor2,*anchor2,*anchor2,*anchor2,*anchor2,*anchor2,*anchor2,*anchor2,*anchor2]',
      Array.from({length: 1000}, (_, i) => `key${i}: ${'x'.repeat(1000)}`).join('\n'),
    ]
  },
  
  // Rate limiting test parameters
  rateLimiting: {
    rapidRequests: 20,
    requestInterval: 100, // ms
    expectedStatus: [429, 503], // Rate limit or service unavailable
  },
  
  // Security headers that should be present
  securityHeaders: {
    'content-security-policy': true,
    'x-frame-options': true,
    'x-content-type-options': true,
    'referrer-policy': true,
    'permissions-policy': false, // Optional but recommended
  },
  
  // Sensitive data patterns to detect in responses
  sensitiveDataPatterns: [
    /password/i,
    /secret/i,
    /token/i,
    /key/i,
    /credential/i,
    /session/i,
  ]
}

test.describe('Input Validation & Injection Protection', () => {
  
  test('prevents XSS attacks through YAML input', async ({ page }) => {
    await page.goto('/playground')
    await page.waitForSelector('[aria-label="YAML input"]')
    
    const yamlInput = page.getByRole('textbox', { name: 'YAML input' })
    const validateBtn = page.getByRole('button', { name: /Validate/ })
    
    for (const payload of SECURITY_CONFIG.injectionPayloads.xss) {
      console.log(`üîç Testing XSS payload: ${payload.substring(0, 50)}...`)
      
      // Test XSS in YAML content
      await yamlInput.clear()
      await yamlInput.fill(`malicious: "${payload}"`)
      await validateBtn.click()
      
      // Wait for response
      await page.waitForSelector('[role="status"], [role="alert"]', { timeout: 5000 })
      
      // Check that script didn't execute
      const alertDialogs = []
      page.on('dialog', dialog => {
        alertDialogs.push(dialog.message())
        dialog.dismiss()
      })
      
      // Verify no XSS execution
      expect(alertDialogs.length).toBe(0)
      
      // Check that dangerous content is properly escaped in DOM
      const pageContent = await page.content()
      expect(pageContent).not.toContain('<script>')
      expect(pageContent).not.toContain('javascript:')
      
      console.log(`‚úÖ XSS payload blocked successfully`)
    }
  })

  test('handles malicious YAML structures safely', async ({ page }) => {
    await page.goto('/playground')
    await page.waitForSelector('[aria-label="YAML input"]')
    
    const yamlInput = page.getByRole('textbox', { name: 'YAML input' })
    const validateBtn = page.getByRole('button', { name: /Validate/ })
    
    for (const payload of SECURITY_CONFIG.injectionPayloads.yamlBombs) {
      console.log(`üîç Testing YAML bomb protection...`)
      
      // Test with timeout to prevent hanging
      const startTime = Date.now()
      
      await yamlInput.clear()
      await yamlInput.fill(payload)
      await validateBtn.click()
      
      try {
        // Should either complete quickly or return an error
        await page.waitForSelector('[role="status"], [role="alert"]', { timeout: 10000 })
        
        const processingTime = Date.now() - startTime
        console.log(`‚è±Ô∏è Processing time: ${processingTime}ms`)
        
        // Should not take more than 10 seconds to process
        expect(processingTime).toBeLessThan(10000)
        
        // Check for appropriate error message
        const alertElement = page.getByRole('alert')
        if (await alertElement.isVisible()) {
          const errorText = await alertElement.textContent()
          console.log(`‚úÖ YAML bomb rejected with error: ${errorText}`)
        }
        
      } catch (error) {
        // Timeout is acceptable for YAML bombs - means protection is working
        console.log(`‚úÖ YAML bomb protection: Request timed out appropriately`)
      }
    }
  })

  test('prevents path traversal attacks', async ({ page }) => {
    await page.goto('/playground')
    await page.waitForSelector('[aria-label="YAML input"]')
    
    const yamlInput = page.getByRole('textbox', { name: 'YAML input' })
    const validateBtn = page.getByRole('button', { name: /Validate/ })
    
    for (const payload of SECURITY_CONFIG.injectionPayloads.pathTraversal) {
      console.log(`üîç Testing path traversal: ${payload}`)
      
      await yamlInput.clear()
      await yamlInput.fill(`file: "${payload}"`)
      await validateBtn.click()
      
      await page.waitForSelector('[role="status"], [role="alert"]', { timeout: 5000 })
      
      // Check response doesn't contain sensitive file contents
      const pageContent = await page.content()
      expect(pageContent).not.toContain('root:')
      expect(pageContent).not.toContain('etc/passwd')
      expect(pageContent).not.toContain('windows\\system32')
      
      console.log(`‚úÖ Path traversal blocked`)
    }
  })

  test('validates file upload security', async ({ page }) => {
    await page.goto('/playground')
    
    // Test file upload with malicious content
    const maliciousYaml = `
# Malicious YAML file
name: "malicious-file"
script: "<script>alert('xss')</script>"
command: "; rm -rf /"
path: "../../etc/passwd"
`
    
    const fileChooser = page.waitForEvent('filechooser')
    const uploadBtn = page.locator('button').filter({ hasText: 'Upload YAML' })
    
    if (await uploadBtn.isVisible()) {
      await uploadBtn.click()
      const chooser = await fileChooser
      
      // Create a temporary malicious file
      const buffer = Buffer.from(maliciousYaml)
      await chooser.setFiles([{
        name: 'malicious.yml',
        mimeType: 'application/x-yaml',
        buffer: buffer
      }])
      
      // Wait for file processing
      await page.waitForTimeout(1000)
      
      // Verify content is safely processed
      const yamlInput = page.getByRole('textbox', { name: 'YAML input' })
      const content = await yamlInput.inputValue()
      
      // Content should be loaded but not executed
      expect(content).toContain('malicious-file')
      
      // Verify no script execution
      const pageContent = await page.content()
      expect(pageContent).not.toContain('<script>')
      
      console.log(`‚úÖ Malicious file upload handled safely`)
    }
  })
})

test.describe('Rate Limiting & DoS Protection', () => {
  
  test('enforces rate limiting on API endpoints', async ({ page, context }) => {
    console.log(`üîç Testing rate limiting with ${SECURITY_CONFIG.rateLimiting.rapidRequests} rapid requests...`)
    
    const responses = []
    const startTime = Date.now()
    
    // Make rapid requests to validation API
    for (let i = 0; i < SECURITY_CONFIG.rateLimiting.rapidRequests; i++) {
      try {
        const response = await context.request.post('/api/validate', {
          data: {
            content: `test${i}: rate-limit-test`,
            provider: 'generic'
          },
          timeout: 5000
        })
        
        responses.push({
          status: response.status(),
          index: i,
          timestamp: Date.now() - startTime
        })
        
        // Small delay to simulate rapid requests
        await page.waitForTimeout(SECURITY_CONFIG.rateLimiting.requestInterval)
        
      } catch (error) {
        responses.push({
          status: 'timeout',
          index: i,
          timestamp: Date.now() - startTime,
          error: error.message
        })
      }
    }
    
    // Analyze responses for rate limiting
    const rateLimitedResponses = responses.filter(r => 
      SECURITY_CONFIG.rateLimiting.expectedStatus.includes(r.status)
    )
    
    console.log(`üìä Rate limiting results:`)
    console.log(`  Total requests: ${responses.length}`)
    console.log(`  Rate limited: ${rateLimitedResponses.length}`)
    console.log(`  Success rate: ${responses.filter(r => r.status === 200).length}`)
    
    // Should have some rate limiting after rapid requests
    expect(rateLimitedResponses.length).toBeGreaterThan(0)
    console.log(`‚úÖ Rate limiting is working`)
  })

  test('handles concurrent user load appropriately', async ({ browser }) => {
    const contexts = await Promise.all(
      Array.from({length: 5}, () => browser.newContext())
    )
    
    const pages = await Promise.all(
      contexts.map(context => context.newPage())
    )
    
    console.log(`üîç Testing concurrent load with ${pages.length} simultaneous users...`)
    
    // Simulate concurrent validation requests
    const validationPromises = pages.map(async (page, index) => {
      try {
        await page.goto('/playground')
        await page.waitForSelector('[aria-label="YAML input"]')
        
        const yamlInput = page.getByRole('textbox', { name: 'YAML input' })
        const validateBtn = page.getByRole('button', { name: /Validate/ })
        
        await yamlInput.fill(`concurrent-user-${index}: load-test`)
        
        const startTime = Date.now()
        await validateBtn.click()
        await page.waitForSelector('[role="status"], [role="alert"]', { timeout: 15000 })
        const endTime = Date.now()
        
        return {
          user: index,
          success: true,
          responseTime: endTime - startTime
        }
      } catch (error) {
        return {
          user: index,
          success: false,
          error: error.message
        }
      }
    })
    
    const results = await Promise.all(validationPromises)
    
    // Clean up
    await Promise.all(contexts.map(context => context.close()))
    
    // Analyze results
    const successfulRequests = results.filter(r => r.success)
    const avgResponseTime = successfulRequests.reduce((sum, r) => sum + r.responseTime, 0) / successfulRequests.length
    
    console.log(`üìä Concurrent load results:`)
    console.log(`  Successful requests: ${successfulRequests.length}/${results.length}`)
    console.log(`  Average response time: ${Math.round(avgResponseTime)}ms`)
    
    // Should handle concurrent load gracefully (at least 80% success rate)
    expect(successfulRequests.length).toBeGreaterThanOrEqual(results.length * 0.8)
    console.log(`‚úÖ Concurrent load handled appropriately`)
  })
})

test.describe('Security Headers & HTTPS', () => {
  
  test('includes required security headers', async ({ page }) => {
    const response = await page.goto('/playground')
    
    console.log(`üîç Checking security headers...`)
    
    const headers = response?.headers()
    if (headers) {
      for (const [headerName, required] of Object.entries(SECURITY_CONFIG.securityHeaders)) {
        const headerValue = headers[headerName]
        
        if (required) {
          expect(headerValue).toBeTruthy()
          console.log(`‚úÖ ${headerName}: ${headerValue}`)
        } else {
          console.log(`‚ÑπÔ∏è ${headerName}: ${headerValue || 'Not set (optional)'}`)
        }
      }
    }
  })

  test('prevents clickjacking with X-Frame-Options', async ({ page, context }) => {
    const response = await page.goto('/playground')
    const headers = response?.headers()
    
    const xFrameOptions = headers?.['x-frame-options']
    
    if (xFrameOptions) {
      expect(['DENY', 'SAMEORIGIN'].some(option => 
        xFrameOptions.toUpperCase().includes(option)
      )).toBe(true)
      
      console.log(`‚úÖ X-Frame-Options: ${xFrameOptions}`)
    }
  })

  test('validates Content Security Policy', async ({ page }) => {
    const response = await page.goto('/playground')
    const headers = response?.headers()
    
    const csp = headers?.['content-security-policy']
    
    if (csp) {
      // Check for important CSP directives
      const cspDirectives = ['default-src', 'script-src', 'style-src', 'img-src']
      
      for (const directive of cspDirectives) {
        if (csp.includes(directive)) {
          console.log(`‚úÖ CSP includes ${directive}`)
        } else {
          console.log(`‚ö†Ô∏è CSP missing ${directive}`)
        }
      }
      
      // Should not allow unsafe-inline or unsafe-eval (with exceptions for development)
      if (csp.includes("'unsafe-inline'") || csp.includes("'unsafe-eval'")) {
        console.log(`‚ö†Ô∏è CSP allows unsafe directives (check if appropriate for environment)`)
      }
    }
  })
})

test.describe('Data Protection & Privacy', () => {
  
  test('does not expose sensitive information in errors', async ({ page }) => {
    await page.goto('/playground')
    await page.waitForSelector('[aria-label="YAML input"]')
    
    const yamlInput = page.getByRole('textbox', { name: 'YAML input' })
    const validateBtn = page.getByRole('button', { name: /Validate/ })
    
    // Test with various malformed YAML to trigger different error conditions
    const errorTriggers = [
      'invalid: yaml: [',
      'malformed:\n  - unclosed',
      'bad-reference: *nonexistent',
      '% invalid character at start'
    ]
    
    for (const trigger of errorTriggers) {
      await yamlInput.clear()
      await yamlInput.fill(trigger)
      await validateBtn.click()
      
      try {
        await page.waitForSelector('[role="alert"]', { timeout: 5000 })
        
        const errorElement = page.getByRole('alert')
        const errorText = await errorElement.textContent()
        
        console.log(`üîç Error message: ${errorText}`)
        
        // Check that error doesn't expose sensitive information
        for (const pattern of SECURITY_CONFIG.sensitiveDataPatterns) {
          expect(errorText).not.toMatch(pattern)
        }
        
        // Should not expose internal file paths or system information
        expect(errorText).not.toContain('/home/')
        expect(errorText).not.toContain('/var/')
        expect(errorText).not.toContain('C:\\')
        expect(errorText).not.toContain('node_modules')
        
        console.log(`‚úÖ Error message does not expose sensitive data`)
        
      } catch (error) {
        // Some invalid YAML might not produce errors, which is fine
        console.log(`‚ÑπÔ∏è No error produced for: ${trigger}`)
      }
    }
  })

  test('handles user data safely', async ({ page }) => {
    await page.goto('/playground')
    await page.waitForSelector('[aria-label="YAML input"]')
    
    const yamlInput = page.getByRole('textbox', { name: 'YAML input' })
    const validateBtn = page.getByRole('button', { name: /Validate/ })
    
    // Test with realistic user data
    const sensitiveData = `
user_data:
  email: "user@example.com"
  password: "secret123"
  api_key: "sk-1234567890abcdef"
  session_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
  credit_card: "4111-1111-1111-1111"
personal:
  ssn: "123-45-6789"
  phone: "+1-555-123-4567"
`
    
    await yamlInput.fill(sensitiveData)
    await validateBtn.click()
    
    await page.waitForSelector('[role="status"], [role="alert"]', { timeout: 5000 })
    
    // Check that sensitive data is not logged or exposed in network requests
    const networkRequests = []
    page.on('request', request => {
      networkRequests.push({
        url: request.url(),
        method: request.method(),
        postData: request.postData()
      })
    })
    
    // Make another request to see if data was logged
    await yamlInput.clear()
    await yamlInput.fill('test: clean-data')
    await validateBtn.click()
    
    await page.waitForSelector('[role="status"]', { timeout: 5000 })
    
    // Verify no sensitive data in subsequent requests
    const postRequestData = networkRequests
      .filter(req => req.method === 'POST')
      .map(req => req.postData || '')
      .join(' ')
    
    expect(postRequestData).not.toContain('secret123')
    expect(postRequestData).not.toContain('4111-1111-1111-1111')
    
    console.log(`‚úÖ Sensitive user data handled safely`)
  })
})

test.describe('Authentication & Authorization Edge Cases', () => {
  
  test('handles unauthenticated access appropriately', async ({ page, context }) => {
    // Test API endpoints without authentication
    const apiEndpoints = [
      '/api/validate',
      '/api/convert',
      '/api/suggest',
      '/health'
    ]
    
    for (const endpoint of apiEndpoints) {
      try {
        const response = await context.request.post(endpoint, {
          data: { content: 'test: unauthenticated' }
        })
        
        console.log(`üìç ${endpoint}: ${response.status()}`)
        
        // Public endpoints should work, private ones should require auth
        if (endpoint === '/health') {
          expect([200, 404]).toContain(response.status())
        } else {
          // Validation endpoints should be accessible (public API)
          expect([200, 400, 422]).toContain(response.status())
        }
        
      } catch (error) {
        console.log(`üìç ${endpoint}: Request failed (${error.message})`)
      }
    }
  })

  test('validates request origin and referrer', async ({ page, context }) => {
    const response = await page.goto('/playground')
    
    // Check if referrer policy is set appropriately
    const referrerPolicy = response?.headers()['referrer-policy']
    
    if (referrerPolicy) {
      const secureRefererPolicies = [
        'strict-origin-when-cross-origin',
        'strict-origin',
        'same-origin',
        'no-referrer'
      ]
      
      const isSecure = secureRefererPolicies.some(policy => 
        referrerPolicy.includes(policy)
      )
      
      expect(isSecure).toBe(true)
      console.log(`‚úÖ Secure referrer policy: ${referrerPolicy}`)
    }
  })
})

test.describe('OWASP Top 10 Coverage', () => {
  
  test('A01: Broken Access Control - validates access restrictions', async ({ page, context }) => {
    // Test attempts to access admin or restricted endpoints
    const restrictedEndpoints = [
      '/admin',
      '/api/admin',
      '/api/users',
      '/api/config',
      '/.env',
      '/config',
      '/server-status'
    ]
    
    for (const endpoint of restrictedEndpoints) {
      try {
        const response = await context.request.get(endpoint)
        const status = response.status()
        
        // Should return 404, 403, or 401 for restricted resources
        expect([404, 403, 401]).toContain(status)
        console.log(`‚úÖ ${endpoint}: ${status} (access denied)`)
        
      } catch (error) {
        console.log(`‚úÖ ${endpoint}: Request failed (properly blocked)`)
      }
    }
  })

  test('A02: Cryptographic Failures - validates secure transmission', async ({ page }) => {
    const response = await page.goto('/playground')
    
    // In production, should be HTTPS
    const url = response?.url()
    const isLocalDev = url?.includes('localhost') || url?.includes('127.0.0.1')
    
    if (!isLocalDev) {
      expect(url).toMatch(/^https:/)
      console.log(`‚úÖ Secure HTTPS transmission`)
    } else {
      console.log(`‚ÑπÔ∏è Local development environment detected`)
    }
  })

  test('A03: Injection - comprehensive injection testing', async ({ page }) => {
    // This combines our earlier injection tests
    console.log(`‚úÖ Injection testing covered in previous test suites`)
    
    await page.goto('/playground')
    await page.waitForSelector('[aria-label="YAML input"]')
    
    // Quick validation that injection protection is active
    const yamlInput = page.getByRole('textbox', { name: 'YAML input' })
    const validateBtn = page.getByRole('button', { name: /Validate/ })
    
    await yamlInput.fill('injection-test: "<script>alert(1)</script>"')
    await validateBtn.click()
    
    await page.waitForSelector('[role="status"], [role="alert"]', { timeout: 5000 })
    
    // Verify no script execution
    const pageContent = await page.content()
    expect(pageContent).not.toContain('alert(1)')
    
    console.log(`‚úÖ A03: Injection protection verified`)
  })
})